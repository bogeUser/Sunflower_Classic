# Python基础
## 1. 什么是lambda函数

- lambda函数，即匿名函数，是只一类无需定义标识符(函数名)的函数或子程序。它的首要用处一般是用在短小的回调函数上。
- lambda函数可以接收任意过个参数(包括可选参数)并返回单个表达式的值。
- lambda函数不能包含命令，且包含的表达式不能超过一个。
- 不一定非要使用lambda表达式。
- 任何可以使用lambda的地方，都可以定义一个单独的普通函数来进行替换。将他们用在需要封装的、非重用代码上，避免令代码充斥着大量的单行函数。
- lambda的返回值是一个函数地址，也就是函数对象。

## 2. python里面如何实现tuple和list的相互转换
直接使用过tuple和list函数就可以了，type()可以判断对象的类型。比如A是一个list，要将它转换成tuple，可以直接用tuple()函数，函数里面的参数刚跟A这个list里面的内容即可。相反，如果想把tuple转换为list也可以用同样的方法。

## 3. 请写一段python代码实现删除一个list里面的重复元素
- 1、使用set函数，set(list)
- 2、使用字典函数

    ```python
    A = [1, 2, 4, 2, 4, 5, 6, 5, 7, 8, 9, 0]
    B = {}
    B = B.fromkeysA)
    C = list(B.keys())
    ```

## 4. python 里如何拷贝一个对象(赋值、浅拷贝、深拷贝的区别)
**赋值**: 简单的拷贝两个对象的引用，使两个对象的id相同

**浅拷贝**: 使用copy模块的copy.copy()方法，它可以进行对象的浅拷贝(shallow copy)，浅拷贝复制了对象，但是对对象中的元素，仍然使用的是引用。也就是说浅拷贝拷贝的是对象本身，不会拷贝对象中引用的其它对象。

**深拷贝**: 使用copy模块的copy.deepcopy()，它可以进行深拷贝，不仅拷贝对象，同时也拷贝了对象中的元素，获得全新的对象，与拷贝对象完全独立，但需要牺牲一定的时间和空间。也即是说深拷贝不仅拷贝对象本身，而且拷贝对象中引用的其它对象。

**copy和deepcopy的区别**: 
- **copy**: 
    - 不可变数据类型，不管copy还是deepcopy，都是同址当浅复制的值是不可变对象(数值，字符串，元祖)时和="赋值"的情况一样，对象的id值与浅复与原来的值相同。
    - 赋值的值是可变对象(列表和字典)
    - 掐拷贝有两种情况:
    1、复制的对象中无复杂子对象，原来值的改变不影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。
    2、复制的对象中有复杂子对象(如列表中的一个子元素是列表)，改变原来的值中的复杂子对象的值，会影响浅复制的值。
- **deepcopy**: 
完全复制独立，包括内层列表和字典

## 5. 介绍一下except的用法和作用

Except在python中用于异常处理，一般和try、finally搭配使用。在try和except中的代码如果发生异常就执行except中的代码，except可以有0个或多个，如果有多个则从上到下根据异常类型进行匹配。finally不管异常是否发生都会执行。

## 6. 介绍一下python下range()函数的用法

range()函数是python的内置函数，它能创建一个整数列表，range()函数大多出现在for循环中，它包含三个参数，第一个参数是start，计算从start开始，默认是0；第二个参数是stop，计数到stop结束，但不包含stop；第三个参数是step，步长，默认是。

## 7. 如何用python来进行查询和替换一个文本字符串

1. 可以使用sub(replacement, string, [, count=0])方法来进行查询和替换。replacement是被替换成的文本，string是需要被替换的文本。count是一个可选参数，值最大被替换的数量。 
2. 使用replace()方法

## 8. Match()和search()的区别

match()函数只检测re模块是不是在String开始位置匹配，search会扫描整个string进行匹配，也就是说match()只有在0位置匹配成功才有返回，如果不是从开始位置匹配成功的话就返回None。

## 9. 用python匹配的HTML tag时，<.*>和<.*?>有何区别

**<.*>**: 贪婪匹配

**<.*?>**: 非贪婪匹配

## 10. python 里如何生成随机数

可以通过random模块生成随机数。

比如生成随机整数: random.randint(a, b) ----返回随机数x， a <= x <= b

```python
random.random(start, stop, [, step]) # 返回一个范围在(start, stop, step)之间的整数，不包括stop
random.random()  # 返回0-1之间的浮点数
random.uniform(a, b)  # 返回指定范围内的浮点数
```

## 11. 有没有一个工具可以帮助查询python的bug和静态的代码分析

PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug，会对代码的复杂格式提出警告。同时PyChecker是一个静态分析工具，它不仅能报告源代码中的错误，而且会报告错误类型和复杂度

## 13. 如何在function里面设置一个全局变量

在function的开始插入一个global声明，global关键字用来在函数或其他局部作用域中使用全局变量。

## 14. 单引号，双引号，三引号的区别

单引号和双引号是等效的，如果要换行，需要符号(\)，三引号则可以直接换行，并可以包含注释

## 15. dict的items()方法和iteritems()方法有何不同

- items()方法将所有的字典以列表方式返回，字典中的项在返回时没有特殊顺序
- iteritems()方法有相似的作用，但返回的是一个可迭代对象

## 16. 如何解决python的模块间引用问题

- 1、从设计架构上，在架构设计之初就要考虑到避免模块的循环引用问题。
- 2、代码布局上，从布局上对可能数显的模块间循环引用问题进行拆分或者合并，保证模块尽量独立。所有的模块最后都有一个层级，不要引用统计或更高级的模块。

## 17. 使用with statement有何好处

with 语句使用所谓上下文管理器对代码进行包装，允许上下文管理器实现一些设置和清理操作。例如，文件可以作为上下文管理使用，他们可以关闭自身作为清理的一部分。

## 18. python 如何实现单例模式

**单例模式(Singleton Pattern)是一种常见的软件设计模式，该模式的主要目的是确保某个类只有一个实例存在。当希望在整个系统重，某个类只能出现一个实例时，就可以用到单例模型时。比如，服务器程序的配置信息文件**

**实现方式: **

- 1、 使用模块

  python的模块就是天然的单例模式，因为模块在第一次导入时，会生成.pyc文件，当第二次被导入时，就会加载.pyc文件，而不会再次执行模块代码。因此，只需要把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。

  ```python
  mysingletion.py
  
  class Singletion(object):
    def foo(self):
      pass
    
    singgleton = Singgleton()
  ```

  将该代码保存在mysingleton.py种，要使用时，直接在其他文件中导入此文件中的对象，这个对象就是一个单例模式的对象。

- 2、使用装饰器

  ```python
  def Singleton(cls):
    _instance = {}
    def inner(*args, **kwargs):
      if cls not in _instance:
        _instance[cls] = cls(*args, **kwargs)
       return _instance[cls]
    return inner
  
  @Singleton
  class A(object):
    a = 1
    def __init__(self, x=0):
      self.x = x
      
  a1 = A(2)
  a2 = A(3)
  ```

- 3、使用类

  ```python
  import time 
  import threading
  
  class Singleton(object):
    _instance_lock = threading.Lock()
    
    def __init__(self):
      time.sleep(1)
      
    @classmethod
    def instance(cls, *args, **kwargs):
      if not hasattr(Singleton, "_instance"):
        with Singleton._instance_lock:
          if not hasattr(Single, "_instance"):
            Singleton._instance = Singleton(*args, **kwargs)
      
      return Singleton._instance
    
    def task(arg):
      obj = Singleton.instance()
      print(obj)
      
    
    for i in range(10):
      t = threadingg.Thread(target=task, args=[i, ])
      
    time.sleep(20)
    obj = Singgleton.instance()
    print(obj)
  ```

- 基于__new__方法实现

  **由于实例化一个对象时，是先执行了类的__new__方法(开发时并没有写，但是默认会调用object.__new__)实例化对象，然后再执行类的__init__()方法，对这个对象进行初始化**

  ```python
  import threading
  
  class Singgleton(object):
    _instance_lock = threading.Lock()
    def __init__(self):
      pass
    
    def __new__(cls, *args, **kwargs):
      if not hasattr(Singleton, "_instance"):
        with Singleton._instance_lock:
          if not hasattr(Singleton, "_instance"):
            Single._instance = object.__new__(cls)
      
      return Single._instance
    
    obj1 = Singleton()
    obj2 = Singleton()
    print(obj1, obj2)
    
  def task(arg):
    obj = Single()
    print(obj)
    
  for i in range(10):
    t = threading.Thread(target=task, args=[i, ])
    t.start()
    
    
  ```

## 19. 什么是装饰器

**装饰器本质上是一个python函数，它可以让其他函数在不需要做任何代码变动的情况下增加额外的功能，它的返回值也是一个函数对象，经常用于有切面需求的场景，比如日志插入，性能测试，事物处理，缓存，权限校验等。有了装饰器，就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。**



**实现: **

```python
def decor(df):
  def warpper(*args, **kwargs):
    print('super')
    df()
  return warpper

@decor
def df():
  print('sum')
  
df()
```

## 20. 什么是语法糖

语法糖指的是那些没有给计算机语言添加新功能，而只是对人们使用起来很"甜蜜"的语法，语法糖往往给程序员提供了更实用的编码方式，有益于更好的编码风格，更易读。不过并没有给语言添加什么东西。

## 21. 参数按值传递和引用传递是怎么实现的

python不允许程序员选择"值传递"还是"引用传递"。python参数传递采用的事"传对象引用"的方式。这种方式更像是值传递和引用传递的一种综合。如果函数收到的是一个可变对象(字典、列表)的引用，就能修改对象的原始值--这相当于"引用传递"。如果函数收到的是一个不可变对象(数字、字符串或元祖)的引用，就不能直接修改原始对象--相当于通过"值传递"来传递对象。

## 22. 如何区别值传递和引用传递

python中区别值传递还是引用传递是根据传入的数据对象决定的，是自动识别的。如果传入的对象时可变对象，如列表，字典，这个时候就是引用传递。如果在传递过程中，参数在函数内被修改，那么眼对象也会被修改。如果传入的对象时不可变的对象，如数字，元祖，字符串，这个时候就是值传递，那么源对象时不可变的。

## 23. 字典推导式和列表推导式是什么

推导式(comprehensions)又称为解析式，是python的一种独有特征。推导式是可以从一种数据序列构建另一种数据序列的结构体。

## 24. python有哪些自带的数据结构

数字、字符串、元祖、列表、字典

数字、字符串、元祖为不可变类型

列表、字典为可变类型

## 25. python2和python3的区别

- python3使用print函数必须以小括号包裹打印的内容，python2可以以小括号的方式，也可以使用一个空格来分隔打印的内容。
- Python2 的range(1， 10)返回列表，python3返回一个迭代器，节约内存。
- python2使用的是ASCII编码，python3使用utf-8编码。
- python2中unicode表示字符串序列，str表示字节序列。python3中str表示字符串序列，byte表示字节序列。
- python2中为正常显示中文，引入了coding声明，python3中不需要。
- python2中raw_input函数表示输入函数，python3中使用input表示输入函数。

## 26. 如何使用socket进行编程

Socket是进程间通信的一种方式，它与其他进程间通信的一个主要不同在于它能实现不同主机间的进程间通信，网络上各种各样的服务大多都是基于socket完成的。要解决网路上两台主机间的进程通信问题，首先要标识该进程。在Tcp/IP网络协议中，就是通过Ip、协议、端口号，三元组来标识进程的。Python中的socket编程主要是通过socket模块完成的。在服务器部分首先要创建一个socket对象，然后打开socket，绑定到特定的地址及端口上，然后监听链接，以后就可以发送数据了。客户端编程的话也是同样要先创建socket，然后链接服务器，得到远程主机的IP地址，当获得远程主机的Ip地址后就可以接收和发送数据了。

## 27.  \_\_new\_\_ 和 \_\_init\_\_ 的区别

- \_\_init\_\_ 是初始化方法，是当实例对象被创建完成后被调用的，当创建完对象之后就立刻被调用了，这个方法可以设置对象属性的一些初始值，并可以接收参数。\_\_init\_\_ 第一个参数为self。是\_\_new\_\_ 返回的实例。\_\_init\_\_在\_\_new\_\_的基础上可以完成一些其他的初始化操作，\_\_init\_\_不需要返回值。
- \_\_new\_\_ 是一个静态方法，是在实例创建之前被调用的，他的任务就是创建实例，然后返回该实例，该方法必须有一个返回值，返回的是被实例化的实例。也就是说\_\_new\_\_ 是在\_\_init\_\_之前被调用，\_\_new\_\_ 的返回值将传递给\_\_init\_\_方法的第一个参数，然后\_\_init\_\_给这个实力设置一些参数。

## 28. 迭代器、生成器、装饰器有何区别

**迭代器**: 任何对象，如果它实现了\_\_next\_\_方法和\_\_iter\_\_方法，那么它就是迭代器，其中\_\_next\_\_方法要么返回迭代器中的下一项，要么返回一个stapIteration异常，\_\_iter\_\_方法返回一个迭代器对象，而它本身就是一个迭代器对象，所以返回的事自身。迭代器可以提供一个中间件即可以帮助我们实现迭代遍历。

**生成器**: 生成器是一个特殊的迭代器，实现了yield关键字的函数就是一个迭代器。调用next()方法，就会返回yield后面的值，然后生成器会暂停执行，当再次使用next()就会从上次暂停的位置开始执行。生成器可以暂停执行，一次只返回一个结果，当程序需要的时候再调用并继续执行，并不会一次性返回所有的结果。

**装饰器**: 装饰器本质上是一个python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外的功能，它的返回值是一个函数对象，经常用于有切面需求的使用场景，比如日志插入，性能测试，事物处理，缓存，权限校验等。有了装饰器，就可以抽离出大量与函数无关的功能。

**生成器和迭代器的区别**: 生成器能做到迭代器能做到的所有事情，因为自动创建了\_\_iter\_\_方法和\_\_next\_\_方法，显得比较简洁，高效。使用生成器表达式比列表解析式更省内存，因为生成器是在需要的时候才会调用\_\_next\_\_方法，而迭代器是一次性返回一个装有所有迭代器内容的列表。

## 29. yield和return的区别

**相同点**: yield和return都是返回程序执行的结果

**区别**: yield返回执行单个结果，但并不会中断程序执行，return返回的是任意结果集，可以返回单个结果，也可以返回多个结果，在返回结果的同时中断程序执行。

## 30. 生成器里面如何得到return返回的结果

通过exception捕获异常，调用捕获到的异常的value()方法就可以得到return返回的结果

## 31. python 中is和==有何区别

- **is**是同一性运算符，用于判断两个变量是否引用的同一个对象，比较的事对象间的唯一身份标识，也就是id是否相同
- **==**是python标准操作负重的比较操作符，用来比较判断两个对象的value是否相等

## 32. python 的异常机制

python中异常也是一个对象，所有的异常的基类都是Exception。捕获异常使用try...except...语法，如果try与exception之间的代码出现错误并且将其异常捕获了，那么代码将会跳转到except中去执行。还可以使用raise去手动触发一个错误，也可以使用assert来触发异常，只不过assert经常用在测试中，并且assert对程序的性能有着极大的影响，只有内置的\_\_debug\_\_为True时assert才会执行。

## 33. python旧式类(经典类)和新式类的区别

- **经典类**:经典类是在创建的时候直接声明继承的object对象。经典类的MRO(Method Resolution Order，方法解析顺序)方法和属性的查找链是按照从左至右，深度优先的方式进行查找的。

- **新式类**: 新式类是在创建的时候继承内置object对象(后者是从内置类型如list、dict等继承)。新式类的MRO采用的是从左到右，广度优先的方式进行查找的。

- **经典类和新式类的区别**: 继承搜索的顺序发生了改变，经典类集成搜索顺序是深度优先，按照从左至右的顺序查找，并且将每个父类的基类都查找一遍。新式类则是，先从左至右的查找，然后再向每一个父类的基类进行查找。(都是从左至右的顺序查找，经典类查找一个父类同时向上查找，新式类则是先查找所有父类然后再向上查找).

## 34. python 中绑定方法和未绑定方法是什么

****

- **绑定方法**: 绑定了实例化的方法即第一个参数是self
- **未绑定方法**: 没有绑定实例化的方法即类方法、静态方法

## 35. python上下文管理器是什么

任何实现了\_\_enter\_\_方法和\_\_exit\_\_方法的对象都称为上下文管理器，比较常见的是实用with语句对上下文管理器进行操作，这样可以对被操作的数据做一些清楚工作。比如通过with打开一个文件，可以替代部分try/finally的工作。with会帮助我们做这一步工作。另外可以通过contextmanager装饰器进一步简化上下文管理器的实现。

## 36. functools的wraps是做什么的

wraps是一个装饰器功能，由于装饰器的函数传入到装饰器时已经不是原函数了，而是一个新的函数，并且丢失一些原函数的属性，为了不影响函数的使用，可以使用wraps来抵消这种副作用。

## 37. ORM的实现原理

ORM使用python的属性描述符协议实现，通过另外一个类来描述类变量的属性类型，在给这个属性进行赋值时(对应数据库中的字段名称)会调用\_\_set\_\_方法，访问属性则会调用\_\_get\_\_方法，删除属性则会调用\_\_delete\_\_方法。

## 38. python字典实现的原理

python的字典使用了哈希表来存储key、value，当添加一个数据时首先会把key通过哈希函数换成一个数字，然后将该数字对存放value的数组长度取余并将取余结果当做数组下标，将value存放在该取余结果为下标的数组中。数据查询时将key转换成对应的数组下标，并定位到数组的位置获取value

## 39. 什么是socket

socket是应用层与Tcp/Ip协议簇通信的中间件抽象层，它是一组接口。在设计模式中，socket其实就是一个门面模式，它把复杂的Tcp/Ip协议簇隐藏在socket接口后面，对用户来说，一组简单的借口就是全部，让socket去组织数据，以符合指定的协议。

## 40. 什么是pickling和uppickling

pickle模块读取任何python对象，将他们转换成字符串，然后使用dump函数将其转存到一个文件中---这个文件叫pickling，反之从存储的字符串文件中提取原始python对象的过程叫uppickling

## 41. 什么是python闭包

**内层函数引用了外部作用域的变量，然后返回内层函数的情况，称为闭包，创建一个闭包必须满足:**

- 必须使用一个内嵌函数
- 内嵌函数必须引用外部函数作用域中的变量。外层空间种被引用的变量叫内层函数的环境变量
- 外部函数的返回之后必须是内嵌函数
- 环境变量和内层非全局函数一起构成闭包

## 42. 自旋锁是什么？和互斥锁应用场景有何不同

- **自旋锁**: 当进程进入CPU时，机会给它的代码上锁，以免被CPU中的进程修改里面的代码(不排除CPU给别的CPU上锁的情况)。当A进入CPU，该进程就会被上锁运行，当进程B来到CPU前，发现CPU被锁了，于是就等待进程A出来交出开锁钥匙。
- **互斥锁**: 如果事物T对数据A加上排他锁后，则其他事物都不能再对A加任何类型的锁，直到在事物的末尾将资源上的锁释放为止。获准排它锁的事物既能读数据，又能修改数据。

## 43. 自旋锁适合哪些应用场景，不适合哪些应用场景

## 44. 怎么用python输出一个Fibonacci数列

```python
a, b = 0, 1;
while b:
  print(b)
  a, b = b, a + b
```

## 45. 介绍一下python中webbrowser的用法

## 46. 解释一下python的and-or语法

与C表达式bool ? a : b 相似，但是 bool and a or b，当个a为假时，不会像C表达式bool ? a : b相同作业。应将and - or 技巧封装成一个函数:

```python
def choose(bool, b):
  return (bool and [a] or [b])[0]
```



## 47. 一行代码实现1-100之和

使用sum()函数求和

```python
sum(range(0, 101))
```

## 48. 如何在一个函数内部修改全局变量

利用global修改全局变量

```python
a = 5
def fn():
  global a
  a = 4

fn()
print(a)
```

## 49. 字典如何删除键和合并两个字典

使用del和update方法

```python
dict = {'name': 'zs', 'age': 18}
del dict['name']
dic
{'age': 18}

dic2 = {'name': 'ls'}
dic.update(dic2)
```

## 50. 装饰器的运用场景

- **参数检查**: 当函数在某些特别的上下文执行时，对其接收或返回的参数进行检查是很有用的。例如，如果某个函数将通过XML-RPC的方式被调用时，python将无法像那些静态类型语言一样能直接提供函数的完整签名。该特性需要再XML-RPC客户端请求函数签名时提供自省能力。XML-RPC是一个轻量级的远程构成调用协议，该协议在HTTP上使用XML来编码它的调用。在简单地客户端-服务器交互中，常使用该协议，而不是用SOAP。不像SOAP会提供一个列出所有可调用函数(WSDL)的页面，XML-RPC没有可用函数的目录

- **缓存**: 缓存装饰器和参数装饰器很像，但是更关注那些内部状态不会影响输出的函数。对于这样的函数，其每一组参数都可以关联到一个独立的结果。这种风格的编程是函数式编程的特色。当输入值的集合是有限的时候可以用。因此，缓存装饰器能将输出结果和产生这个结果所需要的输入参数绑定起来，这样在随后的相同调用中就可以直接返回结果。这种行为叫做记忆，并且使用装饰器来实现是很简单的。

- **代理**

- **提供上下文**

## 51. 用with方法打开处理文件帮我们做了什么

打开文件在进行读写的死后可能会出现异常(比如文件不存在)，如果按照常规的f.open() 写法，那么需要通过try抛出异常，并且文件不管最终遇到什么情况都会执行finally后面的f.close() 关闭文件，with方法帮我们实现了finally中f.close()。

## 52. 列表[1, 2, 3, 4, 5]，请使用map()函数输出[1, 4, 9, 25]， 并使用列表推导式提出大于10的数，最终输出[16, 25]

**map()函数第一个参数fun是一个函数，第二个参数一般是list，第三个参数为可选，可以是list**

```python
list = [1, 2, 3, 4, 5]
def fn(x):
  return x ** 2

res = map(fn, list)
res = [i for i in res if i > 10]
print(res)
```

## 53. python 中生成随机整数，随机小数，0-1之间小数的方法

- **随机整数**:

  ```python
  random.randint(a, b)
  ```

- **随机小数**:

  ```python
  numpy.random.randn(5)
  ```

- **0-1随机小数**:

  ```python
  random.random()
  ```

## 54. 避免转义给字符串添加哪个字母表示原始字符串

r，表示需要原始字符串，不转义特殊字符

## 55. \<div class="nam">中国\</div>，用正则表达式匹配出 标签里面的内容("中国")，其中class的雷鸣是不确定的

```python
import re

str = r'<div calss="nam">中国</div>'
res = re.finall(r'<div calss=".*">(.*?)</div>', str)
```

## 56. python中打断言方法举例

assert() 方法，断言成功，则程序继续执行，断言失败，则程序报错

## 57. s = "ajldjlajfdljfddd"去重，并从小到大排序输出'adfjl'

set去重，去重转成list，利用sort方法排序

## 58. 用lambda函数实现两个数相乘

```python
sum = lambda a, b : a * b
```

## 59. 利用collection库的Counter方法统计字符串每个单词出现的次数

```python
from collection import Counter

a = 'kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h'
res = Counter(a)
print(res)
```

## 60. filter方法求出列表所有奇数并构造新列表， a = [1, 2, 3,  4, 5, 6, 7, 8, 9, 10]

filter()函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该列表接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回True或False。最后将返回True的元素放到新列表

## 61. 正则re.complie的作用

re.compile是将正则表达式编译成一个对象，加快速度，并重复使用

## 62. a = (1, ), b = (1), c = ('1')分别是什么类型的数据

- **a = (1, )**: 表示元祖
- **b = (1)**: 表示int
- **c = ('1')**: 表示字符串

## 63. 两个列表[1, 5, 7, 9]和[2, 2, 6, 8]合并为[1, 2, 2, 6, 7, 8, 9]

extend可以将另外一个集合中的元素逐一添加到列表中，区别在于append是整体添加

## 64. 用python删除文件和Linux命令删除文件的方法

- **python**: os.remove(文件名)
- **Linux**: rm 文件名

## 65. 修改全局变量的值是否必须使用global

在一个函数中，对全局变量进行修改的时候，是否需要使用global要看是否对全局变量的执行指向进行了修改。如果修改了指向，即让全局变量指向了一个新的地方，那么必须使用global。如果仅仅修改了指向的空间中的数据，此时可以不用global。比如，乳沟全局变量是一个列表，在某个函数中向里面添加内容，那么使用append(), remove()等方法不用global，如果是修改里面的某个值，那么就必须使用global。

## 66. 列出任意一种统计图(条形图、折线图)绘制的开源库

**pyecharts、matplotlib**

## 67. [[1,2 ], [3, 4], [5, 6]]一行代码展开列表，得出[1, 2, 3, 4, 5, 6]

- 运行for i in a, 每个i是[1, 2], [3, 4], [5, 6]，for j in i, 每个j是1, 2 3, 4 5, 6合并后的结果
- 将列表转成numpy矩阵，通过运行numpy的flatten()方法

## 68. x = "abc", y="def", z = ["d", "e", "f"]，分别求出x.join(y)和x.join(z)返回的结果

join()括号里面的是可迭代的对象，x插入可迭代对象中间，形成字符串，结果一致

## 69. 举例说明异常模块中try except else finally的相关意义

- **Try...except...else**: 没有捕获异常，执行else
- **try...except...finally**: 不管是否捕获异常，都执行finally

## 70. python中交换两个数值

```python
a, b = 3, 4
print(a, b)
a, b = b, a
print(a, b)
```

## 71. a = "张明 98分", 用re.sub，将98替换为100

```python
import re

a = '张明 98分'
ret = re.sub(r'\d+', 100, a)
```

## 72. 举例说明zip()函数的作用

zip() 函数在运行时，会以一个或多个序列(可迭代对象)，返回一个元祖列表。同时将这些序列中并排的元素配对

zip() 参数可以接收任何类型的序列，同时也可以有两个以上的参数，当传入参数的长度不同时，zip能自动以最短的序列长度为准进行截取，获得元祖。

## 73. a="hello"和b="你好" 编码成bytes类型

```python
a = b'hello'
b = '你好'.encode()
print(a, b)
print(type(a), type(b))
```

## 74. [1, 2, 3] + [4, 5, 6] 的结果是多少

两个列表相加，等价于extend

## 75. list = [2, 3, 5, 4, 9, 6]，从小到大排序，不用sort，输出[2, 3, 4, 5, 6, 9]

利用min() 方法求出最小值，元列表删除最小值，新列表加入最小值，递归调用获得最小值的函数，反复操作。

## 76. 简述cookie和session的区别

- session在服务器端，cookie在客户端
- session运行依赖session id，而session id 是存在cookie中的，也就是说，如果浏览器禁用了cookie，同时session也会失效，存储session时，键与cookie中的session id相同，值是开发人员设置的键值对信息，进行了base64编码，过期时间由开发人员设置
- cookie安全性比session差，因为外界人员可以通过分析存放在本地的cookie并进行cookie欺骗
- session会在一定时间内保存在服务器上。当访问增多时，会比较占用服务器的内存。单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie

## 77. 实例方法、类方法、静态方法的区别与作用

- **实例方法**: 第一个参数是实例对象，一般约定为self，通过它来传递实例的属性和方法，或者是类的属性和方法，只能通过实例调用。
- **类方法**: 使用装饰器@classmethod，第一个参数必须是当前类对象，一般约定为cls，通过它来传递类的属性和方法，不能传递实例的属性和方法。实例对象和类对象都可以调用。
- **静态方法**: 使用装饰器@staticmethod。参数随意，但是方法中不能使用类或实例的任何属性和方法。实例对象和类对象都可以调用。

## 78. 正向代理和反向代理的区别

- **正向代理**:正向代理是一个位于客户端和目标服务器之间的带服务器(中间服务器)。为了从演示服务器取得内容，客户端向代理服务器发送一个请求，并指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须进行一些特别的设置才能使用
- **反向代理**: 反向代理正好相反，对于客户端来首，反向代理就是目标服务器。并且客户端不需要做任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己的一样，因此客户端并不会感知反向代理后面的服务，因此不需要要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了
- **区别**: 正向代理需要主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去访问并返回，而反向代理不需要做任何设置，直接访问服务器真实的ip后者域名，但是服务器内部会自动根据访问内容进行跳转及内容返回，但是不知道最终访问的是哪些机器。正想代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；而反向代理是代理服务器端，为服务器接发请求，使真实服务器对客户端不可见

## 79. 简述 read、readline、readlines的区别

- **read**: 方法表示从文件的当前位置读取size个字节的内容，如果没有设置size的参数，那么表示读取值文件结束为止，他的范围是整个字符串对象
- **readline**: 表示每次读取一行内容，所以读取时占用的内存比较小，比较适合大文件，该方法返回一个字符串对象
- **readlines**: 读取整个文件的所有内容，保存在一个列表变量中，每行作为一个元素，但读取大文件会比较占内存

## 80. 什么是Hash散列函数

## 81. python函数重载的机制

## 82. 为什么函数名可以当做参数用

## 83. 对缺省参数的理解

## 84. 反转一个整数，例如123--->321

```python
class Solution(object):
  def resverse(self, x):
    if -10 < x < 10:
      return x
    
    str_x = str(x)
    
    if str_x[0]! = '_':
      str_x = str_x[::1]
      x = int(str_x)
    else:
      str_x = str_x[1:][::1]
      x = int(str_x)
      x = -x
      
    return x if -2147483648 < x < -2147483648 else 0
  
  if __name__ == '__main__':
    s = Solution()
    reverse_int = s.reverse(-120)
    print(reverse_int)

```

## 85. 设计实现遍历目录与子目录，抓取.pyc文件

```python
import os

def getFiles(dir, suffix):
  res = list()
  
  for root, dirs, files in os.walk(dir):
    for filename in files:
      name, suf = os.path.splitext(filename)
      if suf == suffix:
        res.append(os.path.join(root, filename))
  
  print(res)
  
 getFiles('./', '.pyc')
```

## 86. 面相对象的好处

- 在使用面向过程编程时，当需要对数据进行处理时，需要考虑用哪个模板中哪个函数来进行操作，但是当用面向对象编程时，因为已经将数据存储到这个独立的空间中(这个独立的空间即对象),通过一个特殊的变量(__class__)能够获取到类(模板)，而且这个类中的方法有是有一定数量的，与此类无关的将不会再本类中，因此需要对数据处理时，可以很快的定位需要的方法是谁，这样更方便。
- 全局变量是只能有1份的，很多函数需要更多个备份，往往需要利用其它的变量来进行存储；而通过面向对象中的封装，会将用来存储数据的这个变量变味这个对象中的"全局"变量，只要对象不一样，那么这个变量就可以再有1份，所以这样更方便

## 87. 面型对象的缺点

可控性差，无法像面向过程的程序设计流水线式的可以很精准的预测问题的处理流程和结果，面相对象的程序一旦开始就由对象之间的交互解决问题，很多结果无法预测

## 88. 为什么要有继承

- 能够提升代码的重用率，即开发一个类，可以在多个子功能中直接使用
- 继承能够有效的进行代码管理，当某个类有问题只需要修改这个类就行，而其继承这个类的子类往往不需要修改

## 89. 怎样理解多态

## 90. 简述同源策略

同源策略需要同时满足三点要求

- 协议相同
- 域名相同
- 端口相同

**例如**

```python
http:test.com			https:test.com 		   # 不同源----协议不同
http:test.com     http:admin.com       # 不同源----域名不同
http:test.com     http:test.com.8081   # 不同源----端口不同
```

## 91. 列出几种魔法方法并简要介绍用途

- **\_\_init\_\_**: 对象的初始化方法
- **\_\_new\_\_**: 创建对象的时候执行的方法，单例模式能用到
- **\_\_str\_\_**: 当使用print输出对象时，只要自己定义了\_\_str\_\_(self)方法，那么就会打存在这个方法中return的数据
- **\_\_del\_\_**: 删除对象执行的方法

## 92. 请将[i for i in range (3)] 该为生成器

**生成器是特殊的迭代器**

- 列表表达式的[] 改为() 即可变成生成器
- 函数在返回值的时候出现yield就变成了生成器，而不是函数

## 93. sort和sorted的区别

- **sort是在list的基础上修改的，没有返回值**

- **sorted有返回值，返回的是一个新的list**

## 94. 列举3条以上的PEP8规范

- **顶级定义之间空两行，比如函数或类定义**
- **方法定义，类定义与第一个方法之间，都应该空一行**
- **三引号进行注释**
- **使用Pycharm、Eclipse一般是用空格来缩进代码**

## 95. python中读取Excel文件的方法

**pandas、 xlrt、 xlwt**

## 96. 什么是猴子补丁

在运行期间修改一个类或模块

## 97. python字典核json字符串相互转换的方法

**使用python的json模块**

```python
import json

json.dumps()  # 将字段转为json字符串
json.loads()  # 将json转为字典
```

## 98. 如何以就地操作的方式打乱一个列表的元素

```python
from random import shuffle

shuffle(mylist)
```

## 99. find 和 grep的区别

- **find**: 通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户宿主的文件
- **grep**: grep命令是一种强大的文本搜索工具，grep搜索内容可以使用正则表达式，允许对文本进行模式查找。如果找到匹配模式，grep打印包含模式的所有行

## 100. python中unittest是什么

**unittest是python自带的单元测试框架。它是基于java中流行的单元测试框架junit设计的，其工能强大且灵活。unittest涉及的知识点较多，但它的核心是:**

- 编写一个python类，继承unittest模块中的TestCase类，这就是一个测试类
- 在上面编写的测试类中定义测试方法(测试用例)，每个方法的方法名都要以test大头，没有额外的参数。在该测试方法中调用被测试的代码，检验测试结果，TestCase类提供了很多标准的校验方法，如常见的assertEqual
- 执行unittest.main()，该函数会负责运行测试，它会实例化所有TestCase的子类，并运行其中所有以test打头的方法

## 101. 什么是socket长连接，如何保证socket处于链接状态

## 102. 单例模式的运行场景

## 103. 调用函数带括号和不带括号的区别
带括号的是把返回值返回给调用对象，不带括号是把函数体所在的地址赋给事件，也就是说，带括号的是函数调用，直接性执行函数，不带括号的是绑定事件，事件触发再执行。

## 104. 简述any()和all()方法
- **any()**: 只要迭代器中有一个元素为真，就为真
- **all()**: 迭代器所有的判断项返回都是真的，结果才为真

## 105. IOError、AttributeError、ImportError、IndentationError、IndexError、KeyError、SyntaxError NameError素偶表示的异常

- **IOError**： 输入输出异常
- **AttirbuteError**: 试图访问一个对象没有的属性
- **IndentationError**: 语法错误，代码没有正确的对齐
- **IndexError**: 下标索引超出序列界限
- **SyntaxError**: python代码逻辑语法出错，不能执行
- **NameError**: 使用一个还未赋予对象的变量



