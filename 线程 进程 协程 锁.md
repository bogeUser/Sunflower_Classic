# 线程	进程	协程	锁

## 1. 谈谈对多进程、多线程以及协程的理解

<https://www.cnblogs.com/zhangyux/p/6195860.html>

- **进程**: 
  - 一个运行的程序就是一个进程，进程是资源分配的最小单位，进程拥有自己独立的内存空间，所以进程间数据不共享，且进程开销大。
  - 操作系统进行资源分配和调度的基本单位，多个进程间相互独立。
  - 稳定性好，如果一个进程崩溃，不影响其它进程，但是进程消耗的资源大，开启的进程数量有限制。
- **线程**: 
  - 调度执行的最小单位，现成不能独立存在，必须依赖于进程中，一个进程至少拥有一个线程，叫主线程，而多哥哥线程共享内存(数据共享，共享全局变量)，从而极大地提高了程序的运行效率。
  - CPU进行资源分配和调度的基本单位，线程是进程的一部分，势必进程更小的能独立云心的基本单位，一个进程下的多个线程可以共享该进程的所有资源。
  - 如果IO操作密集，责任可以用多线程提高运行效率，缺点是如果一个线程崩溃，都会造成进程崩溃。
- **协程**:
  - 是一种用户态的请谅解线程，协程的调度完全由用户控制，协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上线文和栈保存到其它地方，再切换回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈基本没有内核切换的开销，可以不加锁访问全局变量，所以上下文切换非常快。python的协程最开始使用yield来实现，当程序运行到yield语句时将程序的控制权交出来去执行其它函数。在python3之前只能通过原生的yield、greenlet、gevent第三方库来实现协程；在python3之后引入 yield from，yield from用于重构生成器。在python3.5后又引入了async和await，其作为yield from， yield的替身。
- **应用**:
  - IO密集使用多线程，在用户输入sleep时，可以切喊道其他线程执行，减少等待时间。
  - CPU密集型的时候使用多进程，因为加入IO减少，用多线程的话，因为线程共享一个全局解释器锁，当前运行的现成占用GIL，其它现成只能等待，就不能充分利用多核CPU的优势。

## 2. Thread和threading有什么区别

## 3. greenlet和gevent有什么区别

## 4.什么是线程竞争

线程是独立的，同一个进程里线程是数据共享过的，当各个线程访问数据资源时会出现竞争状态，即: 数据几乎同步会被多个线程占用，造成数据混乱，即所谓的线程不安全，这就是线程竞争。解决的方法是:给线程加锁，加锁能确保某段关键代码(共享数据资源)只能由一个线程从头到尾完整地执行。从而解决资源竞争下的原子操作问题。但是锁也有坏处，阻止多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，大大降低了效率。

## 5. 什么是锁，常见的锁有哪些

锁(Lock)是对python提供的对线程控制的对象，有互斥锁、可重入锁、死锁

## 6. 什么是死锁

若干个子线程在资源竞争时，都在等待对方对某部分资源解除占用状态，结果是谁都不愿意先解锁，相互一直等着，导致程序无法执行，造成死锁。

## 7. 什么是先成安全 什么是互斥锁

每个对象有对应于一个可称为"互斥锁"的标记，这个标记用来保证在任一时刻，只能有一个线程访问对象。同一个进程种的多线程是共享系统资源的，多个线程同时对一个对象进行操作，一个线程造作尚未结束，另一个线程已经对其进行操作，最终导致结果出现错误，此时需要对被操作的对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。

## 8. 同步、异步、非阻塞

- **同步**:多个任务之间有先后执行顺序，一个执行完后下一个才能执行。
- **异步**: 多个任务间没有先后顺序，可以同时执行。有时候一个任务可能在必要的时候捕获另一个同时执行任务的结果，这叫回调。
- **阻塞**: 如果卡主了调用者，调用者不能继续往下执行，就说明调用者阻塞了。
- **非阻塞**: 如果不会卡住，可以继续执行，那么就是非阻塞。

同步和异步是相对于多任务而言的，阻塞和非阻塞是相对于代码执行而言的

## 9. 什么是僵尸进程和孤儿进程。如何避免僵尸进程

- **孤儿进程**: 父进程退出，子进程还在运行的子进程都是孤儿进程，孤儿进程将被init进程收养，并由init进程对他们完成状态收集工作
- **僵尸进程**:进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获得子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程就是僵尸进程。
- 避免僵尸进程的方法:
  - fork两次用孙子进程去完成子进程的任务
  - 用wait()函数使父进程阻塞
  - 使用信号量，在signal handle中调用waitpid，这样父进程不用阻塞

## 10. python中的进程与线程的使用场景是什么

- **多进程适合在CPU密集型操作)(CPU指令多，如位数多的浮点运算)**
- **多进程适合在IO密集型操作(读写数据操作，如爬虫)**

## 11. 并发和并行

- **并行**: 当进程数量低于CPU的核数时就是并行，并行同一时刻多个任务同时在运行
- **并发**: 当进程数量高于CPU的核数就是并发，并发在同一个时间间隔内多个该任务都在运行，但是并不会在同一时刻都运行，存在交替执行的情况。

## 12. 线程是并发还是并行 进程是并发还是并行

线程是并发，进程是并行

进程之间相互独立，是系统分配资源的最小单位，同一个进程中的所有线程共享资源

## 13. IO密集型和CPU密集型有什么区别

- **IO密集型**: 系统运作，大部分的情况是CPU在对I/O(硬盘、内存)的读/写
- **CPU密集型**: 大部分时间用来做计算，逻辑判断等CPU动作的程序称为CPU密集型

## 14. 进程效率低的原因

进程间不共享任何状态，进程的调度由系统完成，每个进程都有自己独立的内存空间。进程间的通讯主要是通过信号传递的方式来实现的，实现的方式有多种，信号量，管道，事件等，任何一种方式的通讯效率都需要通过内核，导致通讯效率比较低，由于独立的内存空间，上下文切换的时候需要保存先调用栈信息，CPU各寄存器的信息，虚拟内存，以及打开的相关句柄等信息，所以导致上下文进程间切换开销大，通讯麻烦。

## 15. python下多线程的限制以及多进程中传递参数的方式

python多线程有个全局解释器锁(global interpereter lock)，这个锁的意思是任一时间只能有一个线程运用解释锁，跟单CPU跑多个程序一样，需要轮换使用CPU，叫并发。

## 16. 是否了解线程同步

- **线程同步**: 多个线程同时访问同一资源，等待资源访问结束，浪费时间，效率低
- **线程异步**: 在访问资源时，在空闲等待时间同时访问其他资源，实现多线程机制

## 17. 是否了解网络同步和异步

- **网络同步**: 提交请求-等待服务器处理-处理完毕并返回  这期间客户端浏览器不能干任何事情
- **网络异步**: 请求通过事件触发-服务器处理(服务器处理期间浏览器可以做其他事情)-处理完毕

## 18. 如何理解python多线程

python中的多线程有有GIL的影响，导致在任意时间内只有一个线程在运行，所以python的多线程在执行计算密集型任务的时候效果反而不如单线程，只有在处理IO密集型任务的时候，线程才能发挥实力。在等待IO过程中，python的C源码会释放GIL，最终会导致县城在等待IO的过程中被暂停执行其它线程。python中GIL主要是由于历史原因导致Cpython虚拟机中的GIL难以移除，同时GIL的存在保证了多线程之间数据完整性以及状态同步。

## 19. 使用多线程开发可能遇到的问题

**多线程共享全局变量问题，可能导致资源竞争，比如两个线程都需要对某个全局变量进行修改，就可能导致线程1还没有修改完然后切换到线程2开始修改。**

**解决办法**:使用互斥锁，即为了保证一条线程在执行操作的时候，将其他线程上锁。只有当一条线程执行完毕的时候，其他线程解锁执行任务。通过调用threading模块的Lock()类，创建锁(mutex=threading.Lock())，在线程分别调用mutex.acquire()。mutex.acquire()会对线程上锁，如果之前没有上锁，那么此时上锁成功，如果在上锁之前已经被上锁了，那么此时会堵塞在这里，直到这个锁被完全解开为止。然后在线程最后调用mutex.release()解锁。但是使用锁的话可能会造成死锁，即在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源就会造成死锁。死锁是一种状态，即拥有锁的两个线程相互等待对方先做处理。最后就造成死锁。解决死锁的方式是可以给锁添加时间，即某个锁，上锁一定的时间之后会自动release()。从而让其他线程执行。最好的方式是在设计程序的时候尽量避免导致死锁。

## 20. 简述乐观锁和悲观锁

- **悲观锁**:当每次去拿数据的时候都认为别人会修改数据，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里面就用了这种锁机制，比如行锁，表锁，读锁，写锁等，都是在做操作之前先上锁
- **乐观锁**: 每次去拿数据的时候都认为别人不会改锁，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有更新这个数据，可以使用版本号机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量

## 21. 描述数组、链表、队列、堆栈的概念

数组与链表是数据存储方式的概念，数组在连续的空间中存储数据，而链表可以在非连续的空间中存储数据

队列和堆栈是数据存取房时代额概念，队列是先进先出，而堆栈是后进先出；队列和堆栈可以用数组来实现，也可以用链表来实现。

## 22. 什么是异步加载 和同步加载有何区别

- **异步加载**: 异步加载就是在执行过程中加载，通常会使图片之类重要性较次的数据，可以先忽略掉，比如网页游戏经常会在玩的过程中有黑影(未加载图形，由其他黑影模型代替)。如果另一个线程完成了加载，再贴上去，就是异步了
- **同步加载**: 在加载数据时仍然执行其它程序，通常加载时是不执行程序的，不得不等待进度条，因为很多程序在没有加载数据时，可能是无法运行的，所以通常会加载完之后才运行。平时在做网站时常用的就是这种加载形式。





